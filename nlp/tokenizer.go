// Package tok get array of arrays matrix and rebuild it to another form
package tok

func New(m qolumn.Matr) qolumn.Matr{

}


/*

<?php


#############################################################################
# Класс вектора термов
# Именно им нужно пользоваться если обрабатывается числовой ряд
# 
# http://red/__lib2/srf/_test_base_view.php?dvsd
# 
#############################################################################

class srfToken
{

	#------------------------------------------------------------------------
	private $arr;  // данные
	private $sta;  // объект статистики
	#------------------------------------------------------------------------


	#------------------------------------------------------------------------
	# Конструктор
	#------------------------------------------------------------------------
	public function __construct(&$t)
	{
		$this->Assign($t);
	}


	#------------------------------------------------------------------------
	# Объект статистики
	#------------------------------------------------------------------------
	public function stat()
	{
		if(!is_object($this->sta))
		{
			$this->arr['f'] ? '' : $this->F(0);
			$this->sta = new srfStat($this->arr['f']);
		}

		return $this->sta;
	}


	#------------------------------------------------------------------------
	# Присваивание нового вектора
	#------------------------------------------------------------------------
	public function Assign(&$t)
	{
		$r = null;

		$this->arr = array  // сброс кешей
		(
			'var'     => array(), // полный исходник
			'rav'     => array(), // алфавит терм=>индекс
			'src'     => array(), // список индексов
			'tf'      => array(), // частота термов
			'f'       => array(), // вариационный ряд
			't'       => array(), // список термов
			'den_by'  => array(), // tf нормированный по ???

			'length'  => 0, // длина вектора термов
			'size'    => 0,  // кол-во уникальных термов
			'ratio'   => 0,  // отношение site/length
		);


		if($t && (is_array($t) || is_scalar($t)))
		{
			$this->arr['var'] = srf::flat_arr($t);
			$this->arr['rav'] = array_flip($this->arr['var']);

			$this->Length(0);

			for($i=0; $i<$this->arr['length']; $i++)
			{
				$this->arr['src'][] = $this->arr['rav'][ $this->arr['var'][$i] ];
			}

			$r = $this;
		}

		return $r;
	}



	#########################################################################
	### SCALAR ##############################################################
	#########################################################################



	#------------------------------------------------------------------------
	# Длина вектора слов
	#------------------------------------------------------------------------
	public function Length($ret = 1)
	{
		if(empty($this->arr['length']))
		{
			$this->arr['length']	= count($this->arr['var']);
		}

		return $ret
			? $this->arr['length']
			: null;
	}



	#------------------------------------------------------------------------
	# Размер множества слов (кол-во уникальных элементов)
	#------------------------------------------------------------------------
	public function Size($ret = 1)
	{
		if(empty($this->arr['size']))
		{
			$this->arr['size'] = count($this->arr['rav']);
		}

		return $ret
			? $this->arr['size']
			: null;
	}



	#------------------------------------------------------------------------
	# Отношение размеров сжатого списка и полного
	#------------------------------------------------------------------------
	public function Ratio($ret = 1)
	{
		if(empty($this->arr['ratio']))
		{
			$this->arr['length'] ? '' : $this->Length(0);
			$this->arr['size']  ? '' : $this->Size(0);

			$this->arr['ratio'] = $this->arr['length']
				? $this->arr['size']/$this->arr['length']
				: 0;
		}

		return $ret
			? $this->arr['ratio']
			: null;
	}



	#########################################################################
	### VECTOR ##############################################################
	#########################################################################



	#------------------------------------------------------------------------
	# Выборка и хранение уникальных термов
	#------------------------------------------------------------------------
	public function T($ret = 1)
	{
		if(empty($this->arr['t']))
		{
			$this->arr['t'] = array_keys($this->rav);
		}

		return $ret
			? $this->arr['t']
			: null;
	}


	#------------------------------------------------------------------------
	# Выборка числового ряда
	#------------------------------------------------------------------------
	public function F($ret = 1)
	{
		if(empty($this->arr['f']))
		{
			$this->arr['tf'] ? '' : $this->TF(0);
			$this->arr['f'] = array_values($this->arr['tf']);
		}

		return $ret
			? $this->arr['f']
			: null;
	}



	#########################################################################
	### HASH ################################################################
	#########################################################################



	#------------------------------------------------------------------------
	# Частота по используемым термам
	#------------------------------------------------------------------------
	public function TF($ret = 1)
	{
		if(empty($this->arr['tf']))
		{
			$this->arr['tf'] = array_count_values($this->arr['src']);
		}

		return $ret
			? $this->_int_restore($this->arr['tf'])
			: null;
	}



	#########################################################################
	### GENERATORS ##########################################################
	#########################################################################



	#------------------------------------------------------------------------
	# Генератор N-множеств из вектора слов
	#------------------------------------------------------------------------
	public function Sets($l, $sort = 1)
	{
		$arr   = array_values(array_unique($this->src));
		$n     = count($arr);

		$r = array();

		if($n >= $l)
		{
			$start = '';
			$fors  = '';
			$rept  = '';
			$rarr  = array();
			$sc    = str_repeat('}', $l);

			$l--;

			$start = 'for($i'.$l.'=0; $i'.$l.'<$n-'.$l.'; $i'.$l.'++){';
			$rarr  = array('$arr[$i'.$l.']');

			for($i=$l-1; $i>-1; $i--)
			{
				$fors.= 'for($i'.$i.'=$i' . ($i+1) . '+1; $i'.$i.'<$n-'.$i.'; $i'.$i.'++){';
				$rarr[] = '$arr[$i'.$i.']';
			}

			$rept = '$r[]=array(' . implode(',', $rarr) . ');';

			$f = $start.$fors.$rept.$sc;
			eval($f);
		}

		if($sort || $implode !== null)
		{
			foreach($r as $k=>$v)
			{
				sort($r[$k]);
			}
		}

		if($implode !== null)
		{
			$m = count($r);
			for($i=0; $i<$m; $i++)
			{
				$r[$i] = implode($implode, $r[$i]);
			}
		}

		return $r;
	}



	#------------------------------------------------------------------------
	# Генератор N-кортежей с M-смещением
	#------------------------------------------------------------------------
	public function Tuples ($size = 1, $offset = 0, $implode = null, $last_slice = 0)
	{
		$r = array();
		$n = count($this->src);

		if($n >= $size)
		{
			$offset < 1 ? $offset = $size : '';

			for($i=0; $i < $n - $size + 1; $i += $offset)
			{
				$r[] = array_slice($this->src, $i, $size);
			}

			if($last_slice)
			{
				$p = array_slice($this->src, $i);
				$p ? $r[] = $p : '';
			}

			if($implode !== null)
			{
				$m = count($r);
				for($i=0; $i<$m; $i++)
				{
					$r[$i] = implode($implode, $r[$i]);
				}
			}
		}

		return $r;

	}


	
	#------------------------------------------------------------------------
	# Нарезка списка слов по N штук
	#------------------------------------------------------------------------
	public function Slices($size = 0, $implode = null)
	{
		return $this->Tuples($size, $size, $implode, 'and last slice');
	}



	#########################################################################
	### PRIVATE #############################################################
	#########################################################################



	#------------------------------------------------------------------------
	# Восстановление ключей хеша для внешнего использования
	#------------------------------------------------------------------------
	private function _int_restore(&$var)
	{
		$r = array();

		$l = array_keys($var);
		$n = count($l);

		for($i=0; $i<$n; $i++)
		{
			$r[ $this->arr['var'][ $l[$i] ] ] = $var[$l[$i]];
		}
		
		arsort($r);
		return $r;
	}



	#########################################################################
	### THAT'S ALL, FOLKS! ##################################################
	#########################################################################



/*
	Это надо как-то расширить
	#------------------------------------------------------------------------
	# Частота нормированная по максимуму
	#------------------------------------------------------------------------
	public function DenMax($ret = 1)
	{
		if(empty($this->arr['den_max']))
		{
			$this->arr['max'] ? '' : $this->Max(0);
			$this->int_den_calc($this->arr['max'], 'den_max');
		}

		return $ret
			? $this->int_restore($this->arr['den_max'])
			: null;
	}



	#------------------------------------------------------------------------
	# Частота нормированная по сумме
	#------------------------------------------------------------------------
	public function DenSum($ret = 1)
	{
		if(empty($this->arr['den_sum']))
		{
			$this->arr['sum'] ? '' : $this->Sum(0);
			$this->int_den_calc($this->arr['sum'], 'den_sum');
		}

		return $ret
			? $this->int_restore($this->arr['den_sum'])
			: null;
	}
* /


	#########################################################################
	### COLLECTION ##########################################################
	#########################################################################


/*
	#------------------------------------------------------------------------
	# Сборка скалярных расчётов
	#------------------------------------------------------------------------
	public function Scalars()
	{
		return array
		(
			'count' => $this->Count(),
			'size'  => $this->Size(),
			'ratio' => $this->Ratio(),
			'mean'  => $this->Mean(),
			'max'   => $this->Max(),
			'min'   => $this->Min(),
			'sum'   => $this->Sum(),
		);
	}* /


/*
	#------------------------------------------------------------------------
	# Сборка векторных расчётов
	#------------------------------------------------------------------------
	public function Params()
	{
		$this->arr['tf']      ? '' : $this->TF(0);
		$this->arr['size']    ? '' : $this->Size(0);

		$this->arr['den_max'] ? '' : $this->DenMax(0);
		$this->arr['den_sum'] ? '' : $this->DenSum(0);

		$k = array_keys($this->arr['tf']);
		$n = $this->arr['size'];
		$r = array();

		for($i=0; $i<$n; $i++)
		{
			$v = $k[$i];

			$r[$v] = array
			(
				'freq' => $this->arr['tf'][$v],
				'sum'  => $this->arr['den_sum'][$v],
				'max'  => $this->arr['den_max'][$v],
			);
		}

		return $this->int_restore($r);
	}
* /

/*
	#------------------------------------------------------------------------
	# Сборка всех расчётов по типам значений
	#------------------------------------------------------------------------
	public function Calcs()
	{
		return array
		(
			'scalar' => $this->Scalars(),
			'table'  => $this->Params(),
		);
	}

* /
/*
	#------------------------------------------------------------------------
	# Приватный вычислитель разных нормировок на частотность
	#------------------------------------------------------------------------
	private function _int_den_calc(&$base, $name)
	{
		$this->arr['tf']   ? '' : $this->TF(0);
		$this->arr['size'] ? '' : $this->Size(0);

		$tf = $this->arr['tf'];
		$m  = $this->arr['size'];

		$k = array_keys($tf);

		for($i=0; $i<$m; $i++)
		{
			$this->arr[$name][ $k[$i] ] = $this->arr['tf'][ $k[$i] ] / $base;
		}
	}
* /


}


?>

 * /