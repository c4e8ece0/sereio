
###############################################################################
# api_full_http_response() - ассоциативный массив с заголовками и их значениями

###############################################################################
# Сервис просмотра сайта в разных разрешениях
# Проверка на вложенные ноиндексы
# Кроме заголовков и текста показывать ещё и полный ответ сервера
# Проверка роботса на ошибки вёрстки и неправильные/лишние инструкции + перекрывание allow/disallow, правильный хост, наличие указанного сайтмепа
# Определение кодировки в не зависимости от заголовков и мета
# Добавление в панель вебмастера
# Отношение текста после ноиндекса к начальному тексту
# Проверка на антивирусы
# Категории ЯКА, категории DMOZ
# Проверка 301 для роботса на клеющемся хосте
# Показывать какие ссылки закрыты в роботсе/nofollow/noindex и их % в общей массе
# Перекрытия тегов и особенно <noindex>
# Отдельно показывать текст вне тегов <body|html>
# В вёрстку статистику по использованию тегов (кол-во упоминаний, % всего, % заключённого текста)
# А ведь есть ещё аттрибуты альт и тайтл / да по всем аттрибутам можно строить статистику
# Проверка соответствия canonical и полученной страницы
# Валидация css: чтобы паддинги не встречались вместо с высотой/шириной
# Нужен робот, который будет дособирать данные, которые пропустили пользователи
# Проход по страницам вниз нужен ли
# Спеллер в текст добавить
# Выдёргивать цитируемые адреса, не в ссылках
# Проверка указанного размера изображения и фактического
# Whois распределённый - http://projects.arin.net/rwhois/#Web_Clients
# Нужен отлуп на повторное нажатие кнопки, т.е. хранить и передавать дополнительно текущую сессию
# Отношение самого большого куска текста ко всему тексту страницы
# Expired, Verified
# Оценки стоимости
# Освобождающиеся домены
# Регистрировать ли ссылки на другие страницы и хосты как новые?
# Анализ документа и самого большого блока текста в отдельных сервисах (page, text)
# Проверка наличия гугловских заголовков на запрет индексации
# ПРИ МАЛОМ ВРЕМЕНИ ОТЛУПА ПРОСТО ПОКАЗЫВАТЬ ПРЕДЫДУЩИЙ ОТЧЁТ СО ВРЕМЕНЕМ КОГДА ОН БЫЛ ПРОИЗВЕДЁН
# Происходит странное при запросе /test/ (открывается test.php)
# Не забыть оптимизировать минимальную ширину браузера
# Чекать рефера для lat, lng
# API ДОЛЖНО БЫТЬ ГЛОБАЛЬНЫМ, ВНУТРИ ТОЛЬКО ВЫЗОВЫ
# При выборке страницы с http://webimho.ru/ уникодовский неразрывный пробел показывается как "P", найдено в 1 040
# Поиск мнемоник без конечной ";"
# https ссылки сейчас идут в другие
# Защита от ДДОСа - Server: QRATOR
# Проверка клоакинга по Юзер-Агенту
# Кодировка в robots.txt - чтобы не было национальных символов
# Несколько пинов на карте для разных определялок ip, см. maltatour.ru
# http://webimho.ru/topic/59/page__view__findpost__p__2084 - сервису 404, браузер перекидывает
# Как должен обрабатываться robots.txt если в урлах есть русские буквы без кодирования (utf, cp1251)
# Как должен обрабатываться robots.txt есть есть одинаковые правила allow и disallow для одной и той же группы страниц (приоритет у Allow в Яндексе, но нет уточнения до или после добавления / перед *)

/*
Скрипт же проверяет страницу, поэтому привязка должна быть к ней, а не хосту. Точнее и к хосту (роботс, связь) и к странице (плотности и т.п.)
*/


/*

Основные конкуренты Seolib.ru

cy-pr.com 	220 	34248 	196448
xseo.in 	207 	1286 	4717
setlinks.ru 	189 	766 	6027
pr-cy.ru 	154 	4791 	42601
webmasters.ru 	132 	4170 	37585
mainspy.ru 	124 	1128 	8469
ktonanovenkogo.ru 	105 	10213 	262127
url-sub.ru 	103 	1360 	9508
siteposition.ru 	96 	356 	2654
dimok.ru

# Деваковский чеклист надо бы прочекать сюда же


*/


/*
-------------------------------------------------------------------------------
Условная структура разделов
-------------------------------------------------------------------------------

/full/                   - первый сервис
/full/?page              - полный список сайтов по которым была проверка с датой
/full/info/md5(site)/    - полный список сервисов и статус их проверок
/full/info/md5(site)/se/ - отчёт по группе сервисов
/full/news/              - новости сервиса
/full/partner/           - если кто хочет повесить свою рефку или рекламу

-------------------------------------------------------------------------------

*/

\\red\_localhost\www\__lib2\srf\_test_base_view.php


//SRF/web/class.srf_header.php

# Здесь нужно вести статистику и анализ кук на предмет ошибок и допустимых значений
#
# "X-Robots-Tag" не забываем
#
#
# Google: 3xx (redirection)
# Redirects will generally be followed until a valid result can be found (or a loop is recognized). We will follow a limited number of redirect hops (RFC 1945 for HTTP/1.0 allows up to 5 hops) and then stop and treat it as a 404. H
# 
# 
# 3xx (redirection)
# Redirects will generally be followed until a valid result can be found (or a loop is recognized). We will follow a limited number of redirect hops (RFC 1945 for HTTP/1.0 allows up to 5 hops) and then stop and treat it as a 404. Handling of robots.txt redirects to disallowed URLs is undefined and discouraged.
# Handling of logical redirects for the robots.txt file based on HTML content that returns 2xx (frames, JavaScript, or meta refresh-type redirects) is undefined and discouraged.
# 
# 
# Unsuccessful requests or incomplete data
# Handling of a robots.txt file which cannot be fetched due to DNS or networking issues such as timeouts, invalid responses, reset / hung up connections, HTTP chunking errors, etc. is undefined.












morpher.ru - библиотека склонения по падежам


Комбинаторика нужна ли?


Сервис фильтрации слов:

1. Вид аналогично социальным связям
2. Есть статистика по словам, парам, тройкам (колокациям), с возможность выделения балуна
3. Для каждого балуна можно создать правила выборки и фильтрации
4. Возможность задать региональный срез и назначить его на балун (как и прочие фильтры)


Сервис сборки колец длинной M из N сайтов
1. Получаем список доменов или идентификаторов
2. Строим такие группы, чтобы минимальная длина кольца составляля M элементов


Подробности об http
http://php.net/manual/en/class.httpresponse.php

Tokenizer - главная часть всех разборщиков. Для документов и т.д. нужны потоки данных: MEMORY, STREAM и выходные колбеки через интерфейсы??? или пусть вызвавший сам отрабатывает?

srfTerm::Sets - надо будет вынести в отдельный класс для работы с множествами



Нужен класс-мультиплексор для использования нескольких прокси-адресов при связи. При этом как простых, которые просто возвращают значения, так и основанных на srf, чтобы обеспечить какую-то более гибкую работу.



Лемматизаторы и стеммеры
http://stackoverflow.com/questions/771918/how-do-i-do-word-stemming-or-lemmatization

Нужны классы по всем математикам (нечёткой логике, дискретной математике, теории графов, обработке сигналов, временным рядам, etc)



srfAbstactApply
		abstract Filter
		abstract Reduce
		abstract Alpha // соотвествие вход-выход
		abstract Lambda // пропускает коллбек по вектору

		задачи:

	может сделать расширением к srfView, тип MapReduce(func, to), где to - вид представления
	и статистику повесить туда же

		MapAlpha
		MapFilter
		MapReduce
		MapLambda


srfBaseString

				- генератор N-множеств
				- генератор N-множеств с фильтром
				- генератор N-кортежей с M смещением


				А КАК ЖЕ:
				- Отображени слов в цифры и наоборот (с учётом разных источников данных)
				- Фильтрация коротких слов
				- Представление документа как:
					- текста с <a> тегами
					- списка блоков с <a> тегами

				- Перевод слов из одного простраства в другое (упрощение через синонимы)
				- Двухуровневое задание классов обработки:
					word
						common = class
						filter
						explode - уровень списка слов?
						implode - уровень списка слов?
					string
						filter

				
				#-------------------------------------------------------------------------
				# Установка исходного текста
				#-------------------------------------------------------------------------
				//	function Apply($name, $obj)
				//	{
						/* obj - implementation of srfPrepareString() */
				//	}



				/*
					#-------------------------------------------------------------------------
					# Заменяет все небуквенные символы на пробелы + удаляет начальный
					# и конечный пробелы + двойные пробелы
					# $allow - дополнительный список непробельных символов в виде строки или
					# списка нужных букв
					#-------------------------------------------------------------------------
					function Clear($allow = array('')) {}



					#-------------------------------------------------------------------------
					# Фильтрует строки через список callback'ов
					#-------------------------------------------------------------------------
					function Filter($callback = array()){}



					#-------------------------------------------------------------------------
					# Находит следующий токен в строке
					#-------------------------------------------------------------------------
					function TokenNext($delim = array(' '), $offset = 0){}



					#-------------------------------------------------------------------------
					# Находит все токены в строке
					#-------------------------------------------------------------------------
					function TokenList($delim = array(' '), $offset = 0){}



					#-------------------------------------------------------------------------
					# Устанавливает простое представление для текущей строки
					#-------------------------------------------------------------------------
					function doPlain($str)
					//function doNothing - никак не преобразовывать
					//function doAOT     - преобразование к базовой форме
					//function doYandex  - как яндекс-синонимы
					//function doGoogle  - как гугл-синонимы
					//function doSin     - первый по списку синоним
					{
						$cur = 'plain';
						$data[$cur] = sr::plain_str;
					}



					function Str(){}  # переключение на контекст строки
					function Arr(){}  # переключение на контекст вектора



				//	function asInt(){}  # - представление строк в виде кешированных интов в качестве идентификаторов для слов и строк



					function asIs(){}
					function asSet($size, $offset){} # - implode(' ', self::asArrSet) вектор n-грамм слов, size-размер
				*/

				/*
					function statParam(sr::plain_arr('ksort', array('one', 'two')))
					{ // устанавливает флаги для stat_* методов, типа порядка сортировки


					obj->Set(Text)->Clear(/ * cur | def * /|Source)->doPlain()->Tokenize(/ * or current|default * / ini('word.delimeter') as def)->StatTF();
					sr:debug(obj->StatTF());
				}*/


					function statTF(){}   // частота
					//function statTfIdf($idf = class idfClassInterfaceImplemented()){} // частота/doc_freq
					function statMean(){} // средняя
					function statAdaBoost(){} // средняя

					function normStd(){}  // нормализованные значения
					function normBm25(){} // нормализованные значения
					function normHITS(){} // нормализованные значения


					function asN($size, $offset){} # - вектор n-грамм лемм, size-размер, offset - смещение для поиска следующего элемента (size == offset - стоят рядом, size == offset + 1 - один пропуск между элементами)

				// TODO генератор транслитераций
				// TODO генератор строк с соединёнными и разъеденёнными совмещениями букв и цифр нокио н5310 (проверить актуальность)
				// TODO тематика
				// TODO получение частот из внешнего источника должна поддержить позапросное разрешение, групповое разрешение (полная выборка) (с подтверждением ненайденных слов) + настройки внутреннего кеширования


				//	view = [arr, str(implode ' ', arr)] -> asT as asArr
				//	Source
				//	Arr <- explode (SP, plain)
				//	Stat array_count_values (cur_arr)
				//	Uni
				//	Filter // меньше 3 букв, предлоги (нужен список), значимые слова (нужен классификатор)

				//	Аналогично нужны и синонимайзеры: приведение к младшему виду (первый при сортировка синонимов) с подключением к разным библиотекам

				//	Get


srfBaseView

					#---------------------------------------------------------------------
					# Установка/добавление новых вариантов представления или значений
					# к текущему.
					#---------------------------------------------------------------------
					# $name   - название представления
					# $val    - значение
					# $retval - флаг возврата полученного значения (иначе объект)
					# $drop   - флаг сброса значений представлений
					#---------------------------------------------------------------------
				/*
					public function SetView($name, $arr, $retval = 0, $drop = 1)
					{
						if($drop)
						{
							$this->arr[$name] = $arr;
						}
						else
						{
							$n = count($arr);

							for($i=0; $i<$n; $i++)
							{
								$this->arr[$name][] = $arr[$i];
							}
						}

						return $retval ? $arr : $this;
					}
				*/


				/*
					#---------------------------------------------------------------------
					# Присоединение вектора значений к представлению
					#---------------------------------------------------------------------
					# $name   - название представления
					# $arr    - вектор значений
					# $retval - флаг возврата полученного значения (иначе объект)
					#---------------------------------------------------------------------
					public function AddArr($name, $arr, $retval = 0)
					{
						is_array($arr) ? '' : $arr = array($arr);
						$this->SetArr($name, $arr, $retval, 0);
					}


					#---------------------------------------------------------------------
					# Замена/дополнение текущих представлений полученным хешем
					#---------------------------------------------------------------------
					# $arr  - хеш имён=>представлений
					# $drop - указание зачистить текущие представления
					#---------------------------------------------------------------------
					public function Replace($arr, $drop = 1)
					{
						$drop ? $this->_unset() : '';
						$this->arr = is_array($arr) ? $arr : array($arr);

						return $this;
					}


					#---------------------------------------------------------------------
					# Получение кол-ва представлений или значений для текущего объекта
					#---------------------------------------------------------------------
					# $name - название представления 
					#       - '' - вернёт кол-во представлений
					#       - 'name' - вернёт размер вектора для представления $name
					#---------------------------------------------------------------------
					public function Num($name = '')
					{
						return count($name ? $this->arr[$name] : $this->arr);
					}


					#----------------------------------------------------------------------
					# Получение первого значения по имени представления
					#----------------------------------------------------------------------
					# $name - название представления
					#----------------------------------------------------------------------
					public function GetSec($name)
					{
						return isset($this->arr[$name])
							? $this->arr[$name]
							: srf::panic('UNKNOWN_FIELD [' . $name . '|]', __FILE__, __LINE__);
					}

				*/



srf - главный класс


			/*
				#----------------------------------------------------------------------
				# Очистка строки от пробельных символов и удаление пустых элементов
				#----------------------------------------------------------------------
				public static clean_arr($arr)
				{
					return array_filter(array_map('trim', $arr), 'sr::strlen');
				}


				#----------------------------------------------------------------------
				# Суффикс для preg_* для UTF-8
				#----------------------------------------------------------------------
				public static is_u($then)
				{
					return get('common.internal_encoding') ? 'u' : '';
				}

				#----------------------------------------------------------------------
				# Преобразует скаляр как массив с 1 элементом,
				# Многомерный массив становится плоским
				# Другие типы данных дадут array()
				#----------------------------------------------------------------------
				public static arr()
				{
					
				}

				#----------------------------------------------------------------------
				# Перевод строки между кодировками
				#----------------------------------------------------------------------
				abstact private static cp2cp     ($t, $from = '', $to = 'UTF-8');
				abstact public static cp1251_str ($t, $from = '') {}
				abstact public static cp866_str  ($t, $from = '') {}
				abstact public static cpUTF_str  ($t, $from = '') {return self::cp2cp('UTF-8', '');}
			*/




/*

КАК ЗАПРАШИВАТЬ
				 ДАННЫЕ ОТ ИМЕНИ БРАУЗЕРА, ЯНДЕКСА И ГУГЛА РАЗДЕЛЬНО и asодновременно?

				 
				srfBuildStringer
					asExploder
					as Worder

				srfBuildTexter
					asExploder
					asStringer

				srfBuildHtmler
					asTexter
						each.asStringer
					asStringer


				srfBuildBrowser

				srfBuildPipeline

				*/


				//$text = strBuildTexter


				/*
				Возможный пример задания потоков

				$prep = array
				(
					'src'   => new srfStringScalar('', $data = 'somestring to proceed'),
					'word'  => new srfViewStringWord('src'),
					'lower' => new srfViewStringLower('word'), // преобразование слов к нижнему регистру
					'plain' => new srfViewStringPlain('word'), // преобразование строки к нижнему регистру
					'upper' => new srfViewStringUpper('src'),  // преобрзование строки к нижнему регистру
				);


				Задачи:


				1. Парсер сайта с кешером для файлов и картинок (см service_afcity)
					1.1. Многоуровневые проходы по разделам с разбором сложных характеристик на конечных страницах
					(автогермес - unreal, хотя ...)
					1.2. Аудитор сайтов для случая множественных вариантов разбора (WTF?)


				2. Получение данных из входящего потока поблоково и их подготовка/обработка
					2.0. По списку запросов собираются всевозможные статистики
					2.0. По списку троек донор-акцептор-запрос подбираются лучшие N связок
					2.1. Подготовка данных по списку урлов ()
					2.2. Обсервер для аудитора например (новый адрес - список обработок)
					2.3. Т.е. в читателе регистрируется обработчик, который уже обрабатывает данные и раздаёт их своим
					обработчикам (хранитель урлов, стек адресов, хранитель строк, счётчики и пр.)


				>>>> В pipeline роботе должно быть несколько труб для обхода запросов. Пока один запрос обрабатывает 1000 урлов должна
				быть возможность подгрузить следующие очереди на 500 запросов. Вопрос кто должен отрабатывать отлупы.

					Также должна быть возможность работать через внешние свои php-проксеры с проверкой прав доступа и антикапчером.


				>>> Парсер просит входящий поток, в парсере регистрируются нужные автоматы (анализатор роботса, анализатор ссылок,
				анализатор текста, хранитель данных кешер).
				>>>>> После получения блока данных (урла) вызываются
					• хранитель, который это сохраняет
					• и выборщик урлов (на который уже подписана
						• очередь урлов для выборки данных)


				>>>>> Идеально чтобы обработчики запускались в параллельных потоках и не тормозили выборщиков...


				>>>>> Отработка ссылок
					- Учитывать только первую
					- Игнорировать ссылки, начинающиеся с #
					- Учитывать варианты ссылок с хештегом


				class srf Build Parser {}
				class srf Build Pipeline {}
				class srf Build Data {}
*/			




srfStringView

				/**
				 * БЫЛО 
				 * 
				 * Plain
				 * Str2List
				 * Format
				 * Win2Dos
				 * CountWords
				 * UniWord
				 * UniWordExt
				 * UniHash
				 * UniHashExt
				 */


				##############################################################################
				# Внутренний класс для  представления текста в виде вектора строк или таблицы
				# слов.
				# 
				# Строка - это список слов
				# 
				##############################################################################

				class srfStringView
				{
					private $scalar;
					private $array;


					public function __construct($data = '')
					{
						if($data)
						{
							if(is_Scalar($data[0]))
							{
								$scalar = $data;
							}
							elseif(is_array($data[0]))
							{
								$array = $data;
							}
						}
					}


					public function Assign($name, $value)
					{
						$this->data->Assin($name, $value);
					}


					public function asString($implode = ' ')
					{

					}


					public function asWord()
					{

					}
				}
















[стартовый урл] - не обязательно морда

Требуемые отчёты:
1. Уникальность тайтлов (пустые, дубли, суффиксы, префиксы)
2. Внутренняя уникальность страниц (по токенам разной длины, синсеты)
3. Проверка орфографии
4. Проверка вёрстки (правильная вложенность)
5. Проверка мета-тегов и их дублей 
6. Проверка спамности по мешку слов
7. Отсутствующие пассажи под токены
8. Плотности по анкорам входящих внутренних и внешних ссылок
9. Взаимность ссылок (кол-во входящих ссылок со страниц на которые стоит ссылка с текущей)
10. Висячие ссылки (только туда) на html-страницы и отдельно на всякие мультимедии

Настройки:
1. Горизонтальный проход
2. Вертикальный проход
3. Удаляемые теги (noindex, title)
4. Считатать поддомены внешними доменами
5. Сообщать о ссылках на не тот-www
6. Проверять сайтов по внешним ссылкам
7. Кол-во потоков (потребуется подтвердить собственность, которая перепроверяется при каждом запросе на аудит)
8. Включать адрес страницы для оценки включения анкора

Ограничения:
1. Кол-во уровней для прохода 
2. Кол-во страниц для выкачки
3. Задержка


Цепочка команд:
from()->do(passages/)

